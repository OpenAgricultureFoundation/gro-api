"""
This module defines a set of commands that a server can run on itself

This module reads from the following environment variables:

.. envvar:: UWSGI_MASTER_FIFO
    The uWSGI Master FIFO for the parent Django project.

Both of these variable are defined in the :obj:`.env` file generated by
:program:`setup_environment.sh`.
"""

import io
import os
import stat
import select
import logging
import importlib
import subprocess
from django.conf import settings
from django.core.management import call_command, CommandError
from rest_framework.exceptions import APIException
from control.exceptions import (
    InvalidFile, InvalidFifoPath, InvalidFifoFile, InvalidManagerPath
)

fifo_path = os.environ['UWSGI_MASTER_FIFO']
manager_path = os.path.join(settings.BASE_DIR, 'manage.py')
logger = logging.getLogger(__name__)


###################
# Command Classes #
###################

class OutputItem(str):
    """
    A line or set of lines in the output of a command. An
    :class:`~control.command.OutputItem` is just a :class:`str` with an extra
    attribute :attr:`is_error` that reflects whether or not this item resulted
    from an error in it's source program.
    """
    def __new__(cls, text, is_error=False):
        obj = super().__new__(cls, text)
        obj.is_error = is_error
        return obj


class Command:
    """
    A base class for all commands in this module. Subclasses of
    :class:`~control.commands.Command` should define an attribute
    :attr:`returncode` after their :func:`~control.commands.Command.run`
    function has been called reflecting the result of the command that was run.
    They should also define an attribute :attr:`title` that is the name of the
    command being run.
    """
    #: The title of this command
    title = 'Unnamed Command'

    def run(self):
        """
        Runs this command and generates an :class:`~control.commands.OutputItem`
        instance for each item in the output of the command. Subclasses of
        :class:`~control.commands.Command` must implement
        :func:`~control.commands.Command.run`.
        """
        raise NotImplementedError()

    def to_json(self):
        """
        Renders the result of this command as JSON. The response has the keys
        'title' (the title of this command), 'log' (the entire log of the
        command as a string), 'error' (the error messages returned by the
        command), and 'returncode' (the return code of the command).
        """
        log = []
        logger.debug('"{}" command output: '.format(self.title))
        for item in self.run():
            logger.debug(item)
            log.append(item)
        error = [item for item in log if item.is_error]
        response = {
            'title': self.title,
            'log': ''.join(log),
            'error': ''.join(error),
            'returncode': self.returncode
        }
        return response


class ManagerCommand(Command):
    """
    Base class for any commands that run a management command on this project.
    Inherits from :class:`~control.commands.Command`. Subclasses of this
    command must define the attribute :attr:`command_args`, which is a list of
    the arguments to send to
    """
    def run(self):
        stdout = io.StringIO()
        stderr = io.StringIO()
        try:
            call_command(*self.command_args, stdout=stdout, stderr=stderr)
            self.returncode = 0
        except CommandError as e:
            stderr.write(str(e))
            self.returncode = 1
        stdout.seek(0)
        for line in stdout.readlines():
            yield OutputItem(line)
        stderr.seek(0)
        for line in stderr.readlines():
            yield OutputItem(line, True)


class Flush(ManagerCommand):
    title = 'Flush Database'
    command_args = ('flush', '--noinput')


def migrate(app_name=None, migration_name=None):
    if app_name is None and migration_name is not None:
        raise ValueError(
            'An app name is required to uniquely identify a migration by name'
        )
    _command_args = ('migrate',)
    _title = 'Migrate'
    if app_name is not None:
        _command_args += (app_name,)
        _title += ' for app {}'.format(app_name)
    if migration_name is not None:
        _command_args += (migration_name,)
        _title += ' to migration {}'.format(migration_name)
    class Class(ManagerCommand):
        title = _title
        command_args = _command_args
    return Class


class FifoCommand(Command):
    """
    Base class for any commands that write a command to the uWSGI Master FIFO.
    Inherits from :class:`~control.commands.Command`. Subclasses of this command
    must define the attribute :attr:`fifo_command`, which is the command to
    write to the FIFO.
    """
    @classmethod
    def check(self):
        """
        Ensures that the uWSGI Master FIFO to write to exists and is a named
        pipe. Throws the appropriate exception if these conditions are not met.
        """
        if not os.path.exists(fifo_path):
            raise InvalidFifoPath(fifo_path)
        if not stat.S_ISFIFO(os.stat(fifo_path).st_mode):
            raise InvalidFifoFile(fifo_path)

    def on_failure(self):
        """
        This function will be called by
        :func:`~control.commands.FifoCommand.run` if it fails to write to the
        FIFO. This allows subclasses to handle failure differently depending on
        how important their functionality is.
        """
        return
        yield

    def run(self):
        self.check()
        try:
            f = os.open(fifo_path, os.O_WRONLY | os.O_NONBLOCK)
            os.write(f, self.fifo_command)
            os.close(f)
        except OSError:
            yield OutputItem('Failed to write to FIFO\n', True)
            self.returncode = 1
            yield from self.on_failure()
        else:
            yield OutputItem(
                'Wrote {} to "{}"'.format(self.fifo_command, fifo_path),
            )
            self.returncode = 0
        logger.debug('{} returned {}'.format(self.title, self.returncode))
try:
    FifoCommand.check()
except InvalidFile as e:
    if not os.path.exists(fifo_path):
        os.mkfifo(fifo_path)


class ReloadWorkers(FifoCommand):
    """ Reload the uWSGI workers. """
    title = 'Reload Workers'
    fifo_command = b'r'

    def on_failure(self):
        yield OutputItem(
            'We are probably not running behind uWSGI. Assuming Django '
            'development server and attempting touch reload.', True
        )
        if os.environ.get('RUN_MAIN') == 'true':
            touch_reload = TouchReload()
            yield from touch_reload.run()
            self.returncode = touch_reload.returncode
        else:
            yield OutputItem(
                'We are running behind neither uWSGI nor the Django '
                'development server, so I don\'t know how to restart. Manually '
                'restart the server for changes to take effect.', True
            )


class ShellCommand(Command):
    """
    Abstract base class for any commands that perform a command in the console.
    Subclasses of this class must define the attribute :attr:`command`, which is
    the command to run as a string.
    """
    def run(self):
        logger.debug('Running shell command "{}"'.format(self.command))
        proc = subprocess.Popen(
            self.command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        while True:
            reads = [proc.stdout.fileno(), proc.stderr.fileno()]
            ret = select.select(reads, [], [])
            for fd in ret[0]:
                if fd == proc.stdout.fileno():
                    item = b''.join(proc.stdout.readlines()).decode('ascii')
                    yield OutputItem(item)
                if fd == proc.stderr.fileno():
                    item = b''.join(proc.stderr.readlines()).decode('ascii')
                    yield OutputItem(item, True)
            if proc.poll() is not None:
                self.returncode = proc.returncode
                break
        logger.debug('{} returned {}'.format(self.title, self.returncode))


class TouchReload(ShellCommand):
    """ Touch the manage.py file to trigger a Django code reload """
    title = 'Touch Reload'
    command = ' '.join(['touch', manager_path])
