"""
This module abstracts a set of commands that can be run in this project,
including Django management commands, commands written to the uWSGI Master
FIFO, and certain shell commands.

This module reads from the following environment variable:

.. envvar:: UWSGI_MASTER_FIFO
    The uWSGI Master FIFO for the parent Django project.

This variable is defines in the :obj:`.env` file generated by
:program:`setup_environment.sh`.
"""

import io
import os
import sys
import stat
import select
import logging
import subprocess
from django.conf import settings
from django.core.management import call_command
from control.exceptions import (
    InvalidFile, InvalidFifoPath, InvalidFifoFile
)

fifo_path = os.environ['UWSGI_MASTER_FIFO']
manager_path = os.path.join(settings.BASE_DIR, 'manage.py')
logger = logging.getLogger(__name__)


###################
# Command Classes #
###################

class OutputItem(str):
    """
    A line or set of lines in the output of a command.

    :param str text: The text of this item on output
    :param bool is_error: Whether or not this item resulted from an error in
        it's source program. Defaults to False
    """
    def __new__(cls, text, is_error=False):
        obj = super().__new__(cls, text)
        obj.is_error = is_error
        return obj


class Command:
    """
    Abstract base class for all commands in this module. Subclasses of this
    class must define the function :func:`run` and an attribute :attr:`title`
    that is the name of the command being run. Calling an instance of this
    class runs the command.
    """
    #: The title of this command
    title = 'Unnamed Command'

    def __call__(self):
        logger.info('Running command "%s"', self.title)
        for item in self.run():
            if item.is_error:
                logger.warning(item)
            else:
                logger.debug(item)
        log_level = logging.ERROR if self.returncode else logging.INFO
        logger.log(
            log_level, 'Command "%s" finished with returncode "%d"',
            self.title, self.returncode
        )

    def run(self):
        """
        Runs this command and generates an :class:`OutputItem` instance for
        each item in the output of the command. This function must also set an
        instance attribute :attr:`returncode` when it finished that the return
        code of the command that was run.
        """
        raise NotImplementedError()

    def to_json(self):
        """
        Renders the result of this command as JSON. The response has the keys
        'title' (the title of this command), 'log' (the entire log of the
        command as a string), 'error' (the error messages returned by the
        command), and 'returncode' (the return code of the command).
        """
        log = []
        error = []
        for item in self.run():
            if item.is_error:
                logger.warning(item)
                error.append(item)
            else:
                logger.info(item)
            log.append(item)
        response = {
            'title': self.title,
            'log': '\n'.join(log),
            'error': '\n'.join(error),
            'returncode': self.returncode
        }
        return response


class ManagerCommand(Command):
    """
    Base class for any commands that run a management command on this project.
    Inherits from :class:`Command`. Subclasses of this class must define an
    attribute :attr:`command_args`, which is a list of arguments to send to the
    function :func:`~django.core.management.call_command`.
    """
    def run(self):
        stdout = io.StringIO()
        stderr = io.StringIO()
        try:
            call_command(*self.command_args, stdout=stdout, stderr=stderr)
            self.returncode = 0
        except Exception as e:
            stderr.write(str(e))
            self.returncode = 1
        stdout.seek(0)
        for line in stdout.readlines():
            yield OutputItem(line.strip())
        stderr.seek(0)
        for line in stderr.readlines():
            yield OutputItem(line.strip(), True)


class Flush(ManagerCommand):
    """
    Running this command is the equivalent of running `manage.py flush`. It
    clears all of the data in the database.
    """
    title = 'Flush Database'
    command_args = ('flush', '--noinput')


class Migrate(ManagerCommand):
    """
    Running this command is the equivalent of running `manage.py migrate
    [app_label] [migration_name]`, where the parameters `app_label` and
    `migration_name` come from the kwargs passed to the constructor for this
    class.
    """
    def __init__(self, app_label=None, migration_name=None):
        if app_label is None and migration_name is not None:
            raise ValueError(
                'An app name is required to uniquely identify a migration by name'
            )
        command_args = ('migrate',)
        title = 'Migrate'
        if app_label is not None:
            command_args += (app_label,)
            title += ' for app {}'.format(app_label)
        if migration_name is not None:
            command_args += (migration_name,)
            title += ' to migration {}'.format(migration_name)
        self.command_args = command_args
        self.title = title


class FifoCommand(Command):
    """
    Base class for any commands that write a command to the uWSGI Master FIFO.
    Inherits from :class:`Command`. Subclasses of this command must define the
    attribute :attr:`fifo_command`, which is the command to write to the FIFO.
    """
    @classmethod
    def check(self):
        """
        Ensures that the uWSGI Master FIFO to write to exists and is a named
        pipe. Throws the appropriate exception if these conditions are not met.
        """
        if not os.path.exists(fifo_path):
            raise InvalidFifoPath(fifo_path)
        if not stat.S_ISFIFO(os.stat(fifo_path).st_mode):
            raise InvalidFifoFile(fifo_path)

    def on_failure(self):
        """
        This function will be called by :func:`run` if it fails to write to the
        FIFO. This allows subclasses to implement custom recovery procedures.
        """
        yield OutputItem('Failed to write to FIFO', True)

    def run(self):
        self.check()
        try:
            f = os.open(fifo_path, os.O_WRONLY | os.O_NONBLOCK)
            os.write(f, self.fifo_command)
            os.close(f)
        except OSError:
            self.returncode = 1
            yield from self.on_failure()
        else:
            msg = 'Wrote {} to "{}"'.format(self.fifo_command, fifo_path)
            yield OutputItem(msg)
            self.returncode = 0
try:
    FifoCommand.check()
except InvalidFile as e:
    if not os.path.exists(fifo_path):
        os.mkfifo(fifo_path)


class ReloadWorkers(FifoCommand):
    """ Reload the uWSGI workers. """
    title = 'Reload Workers'
    fifo_command = b'r'

    def on_failure(self):
        yield OutputItem(
            'We are probably not running behind uWSGI. Assuming Django '
            'development server and attempting touch reload.'
        )
        if os.environ.get('RUN_MAIN') == 'true':
            touch_reload = TouchReload()
            yield from touch_reload.run()
            self.returncode = touch_reload.returncode
        elif 'test' in sys.argv:
            # We can't actually reload anything, but that's fine because we can
            # get away with just skipping it
            self.returncode = 0
        else:
            yield OutputItem(
                'We are running behind neither uWSGI nor the Django '
                'development server, so I don\'t know how to restart. Manually '
                'restart the server for changes to take effect.', True
            )


class ShellCommand(Command):
    """
    Abstract base class for any commands that perform a command in the console.
    Subclasses of this class must define the attribute :attr:`command`, which
    is the command to run as a string.
    """
    def run(self):
        logger.debug('Running shell command "%s"', self.command)
        proc = subprocess.Popen(
            self.command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
        )
        while True:
            reads = [proc.stdout.fileno(), proc.stderr.fileno()]
            ret = select.select(reads, [], [])
            for fd in ret[0]:
                if fd == proc.stdout.fileno():
                    item = b''.join(proc.stdout.readlines()).decode('ascii')
                    if item:
                        yield OutputItem(item)
                if fd == proc.stderr.fileno():
                    item = b''.join(proc.stderr.readlines()).decode('ascii')
                    if item:
                        yield OutputItem(item, True)
            if proc.poll() is not None:
                self.returncode = proc.returncode
                break


class TouchReload(ShellCommand):
    """ Touch the manage.py file to trigger a Django code reload """
    title = 'Touch Reload'
    command = ' '.join(['touch', manager_path])
